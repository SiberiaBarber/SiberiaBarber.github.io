<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>Hexo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">John Doe</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Hexo</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/25/lock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">lock底层原理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-25</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="content"><p>转载博客链接：<a href="https://yq.aliyun.com/articles/640868" target="_blank" rel="noopener">https://yq.aliyun.com/articles/640868</a> 和 <a href="https://blog.csdn.net/u011109589/article/details/80242931" target="_blank" rel="noopener">https://blog.csdn.net/u011109589/article/details/80242931</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/25/synchronized/">synchronized底层原理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-25</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="content"><p>了解下synchronized的底层原理。转载博客:<a href="https://mp.weixin.qq.com/s?spm=a2c4e.10696291.0.0.587119a4PAEl5l&amp;__biz=MzI3NzE0NjcwMg==&amp;mid=2650121805&amp;idx=1&amp;sn=8aea8c329a018c82a7ebfe80ec604226&amp;chksm=f36bbb6cc41c327acc23d3d7cdf0b785e318d8e970d564ba9ce8b28a1ae6b41499d351497af3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?spm=a2c4e.10696291.0.0.587119a4PAEl5l&amp;__biz=MzI3NzE0NjcwMg==&amp;mid=2650121805&amp;idx=1&amp;sn=8aea8c329a018c82a7ebfe80ec604226&amp;chksm=f36bbb6cc41c327acc23d3d7cdf0b785e318d8e970d564ba9ce8b28a1ae6b41499d351497af3&amp;scene=21#wechat_redirect</a></p>
<p>在《深入理解Java虚拟机》中，有这样一段话：<br>synchronized关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。</p>
<p>海明威在他的《午后之死》说过的：“冰山运动之雄伟壮观，是因为他只有八分之一在水面上。”<br>对于程序员来说，synchronized只是个关键字而已，用起来很简单。之所以我们可以在处理多线程问题时可以不用考虑太多，就是因为这个关键字帮我们屏蔽了很多细节。那么，本文就围绕synchronized展开，主要介绍其用法、原理，以及如何提供原子性、可见性和有序性保障的等。</p>
<h1 id="一、synchronized的用法"><a href="#一、synchronized的用法" class="headerlink" title="一、synchronized的用法"></a>一、synchronized的用法</h1><p>synchronized是Java提供的一个并发控制的关键字。主要有两种用法，分别是同步方法和同步代码块。<br>也就是说，synchronized既可以修饰方法也可以修饰代码块。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被synchronized修饰的代码块及方法，在同一时间，只能被单个线程访问。</p>
<h1 id="二、synchronized的实现原理"><a href="#二、synchronized的实现原理" class="headerlink" title="二、synchronized的实现原理"></a>二、synchronized的实现原理</h1><p>synchronized，是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们想要保证一个共享资源在同一时间只会被一个线程访问到时，我们可以在代码中使用synchronized关键字对类或者对象加锁。</p>
<p>我们对上面的代码进行反编译，可以得到如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello World</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #5                  // class com/hollis/SynchronizedTest</span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: astore_1</span><br><span class="line">         <span class="number">4</span>: monitorenter</span><br><span class="line">         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         8: ldc           #3                  // String Hello World</span><br><span class="line">        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: monitorexit</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">        <span class="number">18</span>: astore_2</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        <span class="number">20</span>: monitorexit</span><br><span class="line">        <span class="number">21</span>: aload_2</span><br><span class="line">        <span class="number">22</span>: athrow</span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>通过反编译后代码可以看出：</p>
<p>对于同步方法，JVM采用ACC_SYNCHRONIZED标记符来实现同步。 </p>
<p>对于同步代码块。JVM采用monitorenter、monitorexit两个指令来实现同步。</p>
<p>在The Java® Virtual Machine Specification中有关于同步方法和同步代码块的实现原理的介绍，我翻译成中文如下：</p>
<p>方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
<p>同步代码块使用monitorenter和monitorexit两个指令实现。可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。 每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p>
<p>无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的，在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由ObjectMonitor实现。</p>
<p>ObjectMonitor类中提供了几个方法，如enter、exit、wait、notify、notifyAll等。sychronized加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/08/LeetCode31/">LeetCode学习——31. Next Permutation</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-08</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/LeetCode/">LeetCode</a></span><div class="content"><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h1 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h1><p>1、从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] &lt; A[j]。此时 [j,end) 必然是降序<br>2、在 [j,end) 从后向前查找第一个满足 A[i] &lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的“小数”、“大数”<br>3、将 A[i] 与 A[k] 交换<br>4、可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序<br>5、如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4</p>
<h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] &lt; A[j]。此时 [j,end) 必然是降序</span></span><br><span class="line">        <span class="comment">//2、在 [j,end) 从后向前查找第一个满足 A[i] &lt; A[k] 的 k。A[i]、A[k] 分别就是上文所说的“小数”、“大数”</span></span><br><span class="line">        <span class="comment">//3、将 A[i] 与 A[k] 交换</span></span><br><span class="line">        <span class="comment">//4、可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序</span></span><br><span class="line">        <span class="comment">//5、如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1、找第一个非降序的相邻元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &lt;= nums[i]) j--;<span class="comment">//步骤2</span></span><br><span class="line">            swap(nums, i, j);<span class="comment">//步骤3</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>, nums.length - <span class="number">1</span>);<span class="comment">//步骤四、五</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/03/LeetCode-Trapping-Rain-Water/">LeetCode学习——42.Trapping Rain Water</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/LeetCode/">LeetCode</a></span><div class="content"><h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p><img src="/2020/02/03/LeetCode-Trapping-Rain-Water/1.PNG" alt="图1"></p>
<p>输入一个数组，请输出该数组能够储水的量。</p>
<h1 id="二、解题"><a href="#二、解题" class="headerlink" title="二、解题"></a>二、解题</h1><p>思路：双指针。假设数组长度为n，首指针为0，尾指针为n-1：</p>
<ol>
<li>leftMax = Math.max(leftMax, height[a]) 并且 rightMax = Math.max(rightMax. height[b]);</li>
<li>假设leftMax &lt; rightMax，则移动左指针，并且左边指针的水会被存储下来，存储的量为leftMax - height[a]; 假设leftMax &gt;= rightMax, 则移动右指针，右边的水被存储，存储的量是 rightMax - height[b];</li>
</ol>
<h1 id="三、具体代码"><a href="#三、具体代码" class="headerlink" title="三、具体代码"></a>三、具体代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (a &lt;= b) &#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[a]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[b]);</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                res += (leftMax - height[a]);</span><br><span class="line">                a++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += (rightMax - height[b]);</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/03/LeetCode32/">LeetCode学习——33.Search in Rotated Sorted Array</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-03</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/LeetCode/">LeetCode</a></span><div class="content"><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>Example 1:</p>
<p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4</p>
<p>Example 2:</p>
<p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p>
<h1 id="一、题意与思路"><a href="#一、题意与思路" class="headerlink" title="一、题意与思路"></a>一、题意与思路</h1><p>目标是找出被旋转的有序数组中的target的下标。思路如下：</p>
<ol>
<li>如果target比A[mid]值要小<ol start="2">
<li>如果A[mid]右边有序（A[mid]&lt;A[high])<ol start="3">
<li>那么target肯定不在右边（target比右边的都得小），在左边找</li>
</ol>
</li>
<li>如果A[mid]左边有序<ol start="5">
<li>那么比较target和A[low]，如果target比A[low]还要小，证明target不在这一区，去右边找；反之，左边找。</li>
</ol>
</li>
</ol>
</li>
<li>如果target比A[mid]值要大<ol start="7">
<li>如果A[mid]左边有序（A[mid]&gt;A[low]）<ol start="8">
<li>那么target肯定不在左边（target比左边的都得大），在右边查找</li>
</ol>
</li>
<li>如果A[mid]右边有序<ol start="10">
<li>那么比较target和A[high]，如果target比A[high]还要大，证明target不在这一区，去左边找；反之，右边找。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//1、如果target大于mid的值</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//1.1  左侧有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; nums[low]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//1.2 右侧有序</span></span><br><span class="line">                    <span class="keyword">if</span> (target &gt; nums[high]) &#123;</span><br><span class="line">                        high = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2、如果target的值小于mid的值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//2.1 右侧有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; nums[high]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2.2 左侧有序</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (target &lt; nums[low]) &#123;</span><br><span class="line">                        low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        high = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/05/select-poll-and-epoll/">select、poll和epoll详解</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/linux%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">linux、IO多路复用</a></span><div class="content"><p>slect，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h1 id="一、select"><a href="#一、select" class="headerlink" title="一、select"></a>一、select</h1><p>int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<h1 id="二、poll"><a href="#二、poll" class="headerlink" title="二、poll"></a>二、poll</h1><p>int poll (struct pollfd *fds, unsigned int nfds, int timeout);</p>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。<strong>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</strong></p>
<h1 id="三、epoll"><a href="#三、epoll" class="headerlink" title="三、epoll"></a>三、epoll</h1><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>epoll的优点主要是一下几个方面：</p>
<ol>
<li><p>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
</li>
<li><p>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</p>
</li>
</ol>
<p>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p>
<p><strong>参考博客链接：<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/30/redis-single-thread/">为什么Redis是单线程还能支持高并发？</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-30</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/redis/">redis</a></span><div class="content"><h1 id="一、Redis为什么是单线程"><a href="#一、Redis为什么是单线程" class="headerlink" title="一、Redis为什么是单线程"></a>一、Redis为什么是单线程</h1><p>Redis单线程实际上是网络请求模块使用了单线程（多路复用），即单个线程处理所有的网络请求。但是其他模块还是使用了多个线程。因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<h1 id="二、Redis为什么处理速度很快"><a href="#二、Redis为什么处理速度很快" class="headerlink" title="二、Redis为什么处理速度很快"></a>二、Redis为什么处理速度很快</h1><ol>
<li><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
</li>
<li><p>使用多路I/O复用模型，非阻塞IO；</p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
</li>
</ol>
<h1 id="三、多路I-O复用模型，非阻塞的IO"><a href="#三、多路I-O复用模型，非阻塞的IO" class="headerlink" title="三、多路I/O复用模型，非阻塞的IO"></a>三、多路I/O复用模型，非阻塞的IO</h1><h2 id="1、IO模式"><a href="#1、IO模式" class="headerlink" title="1、IO模式"></a>1、IO模式</h2><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p>
<h2 id="2、-4种常用IO模型"><a href="#2、-4种常用IO模型" class="headerlink" title="2、 4种常用IO模型"></a>2、 4种常用IO模型</h2><h3 id="2-1-阻塞-I-O（blocking-IO）"><a href="#2-1-阻塞-I-O（blocking-IO）" class="headerlink" title="2.1 阻塞 I/O（blocking IO）"></a>2.1 阻塞 I/O（blocking IO）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="/2019/12/30/redis-single-thread/1.png" alt="图1"></p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<p><strong>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</strong></p>
<h3 id="2-2-非阻塞-I-O（nonblocking-IO）"><a href="#2-2-非阻塞-I-O（nonblocking-IO）" class="headerlink" title="2.2 非阻塞 I/O（nonblocking IO）"></a>2.2 非阻塞 I/O（nonblocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="/2019/12/30/redis-single-thread/2.png" alt="图2"></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p><strong>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</strong></p>
<h3 id="2-3-I-O-多路复用（-IO-multiplexing）"><a href="#2-3-I-O-多路复用（-IO-multiplexing）" class="headerlink" title="2.3 I/O 多路复用（ IO multiplexing）"></a>2.3 I/O 多路复用（ IO multiplexing）</h3><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 </p>
<p><img src="/2019/12/30/redis-single-thread/3.png" alt="图3"></p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="2-4-异步-I-O（asynchronous-IO）"><a href="#2-4-异步-I-O（asynchronous-IO）" class="headerlink" title="2.4 异步 I/O（asynchronous IO）"></a>2.4 异步 I/O（asynchronous IO）</h3><p>Linux下的asynchronous IO其实用得很少。先看一下它的流程:</p>
<p><img src="/2019/12/30/redis-single-thread/4.png" alt="图4"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h2 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h2><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h2 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h2><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p>non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p>下一篇记录下select、poll和epoll的区别</p>
<p>参考博客：<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a>;<br><a href="https://blog.csdn.net/u010623927/article/details/87918603" target="_blank" rel="noopener">https://blog.csdn.net/u010623927/article/details/87918603</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/29/RedisHashSlot/">一致性哈希和哈希槽的对比</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-29</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a></span><div class="content"><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>随着memcache和redis的出现，更多人认识到了一致性哈希。</p>
<p>一致性哈希用于解决分布式缓存系统中的数据选择节点存储问题和数据选择节点读取问题以及在增删节点后减少数据缓存的消失范畴，防止雪崩的发生。</p>
<p>哈希槽是在redis cluster集群方案中采用的，redis cluster集群没有采用一致性哈希方案，而是采用<strong>数据分片</strong>中的哈希槽来进行数据存储与读取的。</p>
<h1 id="二、一致性哈希"><a href="#二、一致性哈希" class="headerlink" title="二、一致性哈希"></a>二、一致性哈希</h1><p>一致性hash是一个0-2^32的闭合圆，（拥有2^23个桶空间，每个桶里面可以存储很多数据，可以理解为s3的存储桶）所有节点存储的数据都是不一样的。计算一致性哈希是采用的是如下步骤：</p>
<ol>
<li>对节点进行hash,通常使用其节点的ip或者是具有唯一标示的数据进行hash(ip),将其值分布在这个闭合圆上。</li>
<li>将存储的key进行hash(key),然后将其值要分布在这个闭合圆上。</li>
<li>从hash(key)在圆上映射的位置开始顺时针方向找到的一个节点即为存储key的节点。如果到圆上的0处都未找到节点，那么0位置后的顺时针方向的第一个节点就是key的存储节点。</li>
</ol>
<h3 id="添加节点带来的影响"><a href="#添加节点带来的影响" class="headerlink" title="添加节点带来的影响"></a>添加节点带来的影响</h3><p>图1为一致性hash的分布情况，箭头指向key的分布情况。<br><img src="/2019/12/29/RedisHashSlot/pic1.jpg" alt="图1"></p>
<p>如果现在node2和node4节点中间增加一个node5节点，那么在node4和node2之间的这些数据要存储的节点就会有所变化。在图中的黄色区域的数据将会从原来的node4节点挪到node5节点。</p>
<h3 id="删除节点带来的影响"><a href="#删除节点带来的影响" class="headerlink" title="删除节点带来的影响"></a>删除节点带来的影响</h3><p>以图1为基准，删除了node2节点后，原本在node2节点上的数据就会被重新定位node4上。这样就产生一个影响：原来node2的数据转移到node4上，这样node4的内存使用率会骤增，如果node2上存在热点数据，node4会扛不住甚至会可能挂掉，挂掉之后数据又转移给node3,如此循环会造成所有节点崩溃，也就是前面所说的雪崩的情况。</p>
<h3 id="节点太少的影响"><a href="#节点太少的影响" class="headerlink" title="节点太少的影响"></a>节点太少的影响</h3><p>节点太少的话可能造成数据倾斜的情况，如图中中只有俩节点，可能会造成大量数据存放在node A节点上，而node B节点存储很少的数据。</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>为了解决雪崩现象和数据倾斜现象，提出了虚拟节点这个概念。就是将真实节点计算多个哈希形成多个虚拟节点并放置到哈希环上，定位算法不变，只是多了一步虚拟节点到真实节点映射的过程</p>
<p>以雪崩现象来说明:如下图节点real1节点又俩个虚拟节点v100和v101,real2有俩个虚拟节点v200和v201，real3节点有v300和v301俩个虚拟节点。</p>
<p><img src="/2019/12/29/RedisHashSlot/pic2.jpg" alt="图1"></p>
<p>当real1节点挂掉后，v100和v101节点也会随即消失，这时k1数据就会被分配到v301上，k4就会被分配到了v200上，这就解决了雪崩的问题，当某个节点宕机后，其数据并没有全部分配给某一个节点，而是被分到了多个节点。</p>
<p>正因为加入了虚拟节点机制，数据倾斜的问题也随之解决</p>
<p>注意：真实节点不放置到哈希环上，只有虚拟节点才会放上去。</p>
<h3 id="为什么要使用闭合的哈希环？"><a href="#为什么要使用闭合的哈希环？" class="headerlink" title="为什么要使用闭合的哈希环？"></a>为什么要使用闭合的哈希环？</h3><p>举个例子，如果在2^23-3处有一个key,而2^23-3~2^23处并没有节点,那么这个key该存在哪里节点呢？说到这里你应该明白来吧。</p>
<h1 id="三、哈希槽"><a href="#三、哈希槽" class="headerlink" title="三、哈希槽"></a>三、哈希槽</h1><p>redis cluster采用数据分片的哈希槽来进行数据存储和数据的读取。redis cluster一共有2^14（16384）个槽，所有的master节点都会有一个槽区比如0～1000，槽数是可以迁移的。master节点的slave节点不分配槽，只拥有读权限。但是注意在代码中redis cluster执行读写操作的都是master节点，并不是你想 的读是从节点，写是主节点。第一次新建redis cluster时，16384个槽是被master节点均匀分布的。</p>
<p><strong>和一致性哈希相比：</strong></p>
<p>它并不是闭合的，key的定位规则是根据CRC-16(key)%16384的值来判断属于哪个槽区，从而判断该key属于哪个节点，而一致性哈希是根据hash(key)的值来顺时针找第一个hash(ip)的节点，从而确定key存储在哪个节点。<br>一致性哈希是创建虚拟节点来实现节点宕机后的数据转移并保证数据的安全性和集群的可用性的。redis cluster是采用master节点有多个slave节点机制来保证数据的完整性的,master节点写入数据，slave节点同步数据。当master节点挂机后，slave节点会通过选举机制选举出一个节点变成master节点，实现高可用。但是这里有一点需要考虑，如果master节点存在热点缓存，某一个时刻某个key的访问急剧增高，这时该mater节点可能操劳过度而死，随后从节点选举为主节点后，同样宕机，一次类推，造成缓存雪崩。解决这个问题请看我的另一篇文章如何应对热点缓存问题</p>
<p>注意：新建的master节点是没有槽区的，需要给master节点分配槽，不然缓存无法命中。分配槽的方法自行百度。<br>删除master节点</p>
<ol>
<li>如果主节点有从节点，需要将从节点转移到别的主节点上。</li>
<li>转移后 如果主节点有哈希槽，去调哈希槽，然后在删除master节点<br>注意：redis cluster的动态扩容和缩容并不会影响集群的使用。</li>
</ol>
<p><strong>原博客链接：<a href="https://www.jianshu.com/p/4163916a2a8a" target="_blank" rel="noopener">https://www.jianshu.com/p/4163916a2a8a</a></strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/10/new-blog/">LeetCode学习——	22. Generate Parentheses(生成括号)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-10</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/backtrack-leetcode/">backtrack leetcode</a></span><div class="content"><h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:<br>【<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>】</p>
<h1 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h1><p>回溯法：当左括号的数量（解法中的openNum）小于max，可以添加”(“；当右括号的数量（closeNum）小于左括号的数量，添加”)”；当字符串的长度等于2n时，说明已经达到叶节点，可以放进result集合中。</p>
<p>tips：可以把每次调用backtrack看作为一次二叉树的分叉，添加左括号向左分叉；添加右括号向右分叉。我们只需将叶子节点的值全部收集起来就可，但是分叉条件是必须满足左括号数量始终大于等于右括号数量。</p>
<h1 id="三、解答"><a href="#三、解答" class="headerlink" title="三、解答"></a>三、解答</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(res, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; list, String str, <span class="keyword">int</span> openNum, <span class="keyword">int</span> closeNum, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">2</span> * max) &#123;</span><br><span class="line">            list.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (openNum &lt; max) &#123;</span><br><span class="line">            backtrack(list, str + <span class="string">"("</span>, openNum + <span class="number">1</span>, closeNum, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closeNum &lt; openNum) &#123;</span><br><span class="line">            backtrack(list, str + <span class="string">")"</span>, openNum, closeNum + <span class="number">1</span>, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/17/LeetCode/">LeetCode学习——11. Container With Most Water</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-17</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/LeetCode/">LeetCode</a></span><div class="content"><h1 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h1><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<p>Example:</p>
<p>Input: [1,8,6,2,5,4,8,3,7]<br>Output: 49</p>
<h1 id="二、解答"><a href="#二、解答" class="headerlink" title="二、解答"></a>二、解答</h1><h1 id="1、暴力解法"><a href="#1、暴力解法" class="headerlink" title="1、暴力解法"></a>1、暴力解法</h1><p>直接遍历所有的坐标组合，找到最大的容积。时间复杂度O（n^2）;</p>
<h1 id="2、贪心算法"><a href="#2、贪心算法" class="headerlink" title="2、贪心算法"></a>2、贪心算法</h1><p>时间复杂度O（n）。</p>
<p>从坐标的一头一尾向中心收缩，每一步比较左右边界的高度，高度较小的向里移动一步。然后根据新的坐标计算出容积，和原来的容积相比取较大的容积。</p>
<p>这个贪心算法,为什么最优解不会被错过？<br>反证法，假设会被错过。假设最优解是横坐标为x1,x2(x2在右边)的这两个点组成的，只考虑扫描到x2时,x1被错过的情况(x2被错过同理)：被错过指的是,当右指针向左扫描经过x2之后,左指针还在x1的左边P处时,x1被错过。</p>
<p>（1）情况一   x2&gt;p:  x2会被保留,然后左指针向右移动到x1,x1不会被错过<br>（2）情况二   x2&lt;p:<br>  小情况一：height[p]&gt;height[x1]，则最优解为 p,x2而不是 x1,x2。假设不成立。<br>  小情况二：p&lt;=x1  最优解还是p,x2。 因为x2比p和x1都小,所以容器高度取决于x2,而p比x1偏左,所以p,x2比x1,x2面积大。假设不成立。</p>
<p>这种算法保证了[x1,x2] 的长度是最大的，并且x1, x2 都是彼此搭配最高的。</p>
<p>解答代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = getArea(height, i, j);</span><br><span class="line">            res = res &lt; area ? area : res;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">(<span class="keyword">int</span>[] height, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area = (j - i) * Math.min(height[i], height[j]);</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By John Doe</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>