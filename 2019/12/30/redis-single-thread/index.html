<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="为什么Redis是单线程还能支持高并发？"><meta name="keywords" content="redis"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>为什么Redis是单线程还能支持高并发？ | Hexo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Redis为什么是单线程"><span class="toc-number">1.</span> <span class="toc-text">一、Redis为什么是单线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Redis为什么处理速度很快"><span class="toc-number">2.</span> <span class="toc-text">二、Redis为什么处理速度很快</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、多路I-O复用模型，非阻塞的IO"><span class="toc-number">3.</span> <span class="toc-text">三、多路I/O复用模型，非阻塞的IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、IO模式"><span class="toc-number">3.1.</span> <span class="toc-text">1、IO模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、-4种常用IO模型"><span class="toc-number">3.2.</span> <span class="toc-text">2、 4种常用IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-阻塞-I-O（blocking-IO）"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 阻塞 I/O（blocking IO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-非阻塞-I-O（nonblocking-IO）"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 非阻塞 I/O（nonblocking IO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-I-O-多路复用（-IO-multiplexing）"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 I/O 多路复用（ IO multiplexing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-异步-I-O（asynchronous-IO）"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 异步 I/O（asynchronous IO）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、总结"><span class="toc-number">4.</span> <span class="toc-text">三、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#blocking和non-blocking的区别"><span class="toc-number">4.1.</span> <span class="toc-text">blocking和non-blocking的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronous-IO和asynchronous-IO的区别"><span class="toc-number">4.2.</span> <span class="toc-text">synchronous IO和asynchronous IO的区别</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">John Doe</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">为什么Redis是单线程还能支持高并发？</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-30</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="一、Redis为什么是单线程"><a href="#一、Redis为什么是单线程" class="headerlink" title="一、Redis为什么是单线程"></a>一、Redis为什么是单线程</h1><p>Redis单线程实际上是网络请求模块使用了单线程（多路复用），即单个线程处理所有的网络请求。但是其他模块还是使用了多个线程。因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<h1 id="二、Redis为什么处理速度很快"><a href="#二、Redis为什么处理速度很快" class="headerlink" title="二、Redis为什么处理速度很快"></a>二、Redis为什么处理速度很快</h1><ol>
<li><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p>
</li>
<li><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
</li>
<li><p>使用多路I/O复用模型，非阻塞IO；</p>
</li>
<li><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
</li>
</ol>
<h1 id="三、多路I-O复用模型，非阻塞的IO"><a href="#三、多路I-O复用模型，非阻塞的IO" class="headerlink" title="三、多路I/O复用模型，非阻塞的IO"></a>三、多路I/O复用模型，非阻塞的IO</h1><h2 id="1、IO模式"><a href="#1、IO模式" class="headerlink" title="1、IO模式"></a>1、IO模式</h2><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking IO）</li>
<li>非阻塞 I/O（nonblocking IO）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven IO）</li>
<li>异步 I/O（asynchronous IO）</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p>
<h2 id="2、-4种常用IO模型"><a href="#2、-4种常用IO模型" class="headerlink" title="2、 4种常用IO模型"></a>2、 4种常用IO模型</h2><h3 id="2-1-阻塞-I-O（blocking-IO）"><a href="#2-1-阻塞-I-O（blocking-IO）" class="headerlink" title="2.1 阻塞 I/O（blocking IO）"></a>2.1 阻塞 I/O（blocking IO）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="/2019/12/30/redis-single-thread/1.png" alt="图1"></p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<p><strong>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</strong></p>
<h3 id="2-2-非阻塞-I-O（nonblocking-IO）"><a href="#2-2-非阻塞-I-O（nonblocking-IO）" class="headerlink" title="2.2 非阻塞 I/O（nonblocking IO）"></a>2.2 非阻塞 I/O（nonblocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="/2019/12/30/redis-single-thread/2.png" alt="图2"></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p><strong>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</strong></p>
<h3 id="2-3-I-O-多路复用（-IO-multiplexing）"><a href="#2-3-I-O-多路复用（-IO-multiplexing）" class="headerlink" title="2.3 I/O 多路复用（ IO multiplexing）"></a>2.3 I/O 多路复用（ IO multiplexing）</h3><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 </p>
<p><img src="/2019/12/30/redis-single-thread/3.png" alt="图3"></p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="2-4-异步-I-O（asynchronous-IO）"><a href="#2-4-异步-I-O（asynchronous-IO）" class="headerlink" title="2.4 异步 I/O（asynchronous IO）"></a>2.4 异步 I/O（asynchronous IO）</h3><p>Linux下的asynchronous IO其实用得很少。先看一下它的流程:</p>
<p><img src="/2019/12/30/redis-single-thread/4.png" alt="图4"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h2 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h2><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h2 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h2><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p>non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<p>下一篇记录下select、poll和epoll的区别</p>
<p>参考博客：<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a>;<br><a href="https://blog.csdn.net/u010623927/article/details/87918603" target="_blank" rel="noopener">https://blog.csdn.net/u010623927/article/details/87918603</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://siberiabarber.github.io/2019/12/30/redis-single-thread/">https://siberiabarber.github.io/2019/12/30/redis-single-thread/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/01/05/select-poll-and-epoll/"><i class="fa fa-chevron-left">  </i><span>select、poll和epoll详解</span></a></div><div class="next-post pull-right"><a href="/2019/12/29/RedisHashSlot/"><span>一致性哈希和哈希槽的对比</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By John Doe</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>